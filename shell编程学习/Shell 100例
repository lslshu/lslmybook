1.编写hello world脚本

#！bin/bash
echo "Hello world"

2.通过位置变量创建liunx系统账户及密码

#！bin/bash
# 通过位置变量创建 Linux 系统账户及密码
#$1 是执行脚本的第一个参数,$2 是执行脚本的第二个参数
useradd "$1"
echo "$2" | passwd --stdin "$1"

3.备份日志

#！bin/bash
# 每周 5 使用 tar 命令备份/var/log 下的所有日志文件
# vim  /root/logbak.sh
# 编写备份脚本,备份后的文件名包含日期标签,防止后面的备份将前面的备份数据覆盖
# 注意 date 命令需要使用反引号括起来,反引号在键盘<tab>键上面
tar	-czf	log-`date +%Y%m%d`.tar.gz	/var/log

# crontab ‐e	#编写计划任务,执行备份脚本
00	03	*	*	5	/root/logbak.sh

4.一键部署lnmp

#！bin/bash
# 一键部署 LNMP(RPM 包版本)
# 使用 yum 安装部署 LNMP,需要提前配置好 yum 源,否则该脚本会失败
# 本脚本使用于 centos7.2 或 RHEL7.2
yum install httpd -y
yum install mariadb mariadb-devel mariadb-server -y
yum install php php-mysql -y

systemctl start httpd mariadb
systemctl enable httpd mariadb

5.监控内存和磁盘容量，小于给定值时报警
# 实时监控本机内存和硬盘剩余空间,剩余内存小于500M、根分区剩余空间小于1000M时,发送报警邮件给root管理员
# 提取根分区剩余空间
disk_size=$(df -H / | awk '/\//{print $4}')
#提取内存剩余空间
mem_size=$(free -h | awk '/Mem/{print $4}')
while:
do
#注意内存与磁盘提取空间大小是以M和G为单位
if [[ $disk_size -le 1 -a $mem_size -le 500 ]]; then
	mail -s "Warning" root <<EOF
	资源不足
EOF
fi
done

6.猜数字游戏
#！bin/bash
# 脚本生成一个 100 以内的随机数,提示用户猜数字,根据用户的输入,提示用户猜对了,
# 猜小了或猜大了,直至用户猜对脚本结束。
# RANDOM 为系统自带的系统变量,值为 0‐32767的随机数
# 使用取余算法将随机数变为 1‐100 的随机数

num=$[RANDOM%100+1]
echo "$num"
# 使用 read 提示用户猜数字
# 使用 if 判断用户猜数字的大小关系:‐eq(等于),‐ne(不等于),‐gt(大于),‐ge(大于等于),
# ‐lt(小于),‐le(小于等于)
while ：
do
	read -p "随机1-100，猜数字：" cai
	if [[ $cai -eq $num ]]; then
		#statements
		echo "猜对了"
		exit
	    elif [[ $cai -gt $num ]]; then
			#statements
			echo "大了"
		else
			echo "小了"
	fi
done

7.检测本机当前用户是否为超级管理员,如果是管理员,则使用 yum 安装 vsftpd,如果不是,则提示您非管理员(使用字串对比版本)
#!/bin/bash
# 检测本机当前用户是否为超级管理员,如果是管理员,则使用 yum 安装 vsftpd,如果不是,则提示您非管理员(使用字串对比版本) 
if [[ $USER == "root" ]]; then
	#statements
	yum install vsftpd -y
else
	echo "你不是管理员，没有安装权限"
fi

8.检测本机当前用户是否为超级管理员,如果是管理员,则使用 yum 安装 vsftpd,如果不是,则提示您非管理员(使用 UID 数字对比版本)
#!/bin/bash
# 检测本机当前用户是否为超级管理员,如果是管理员,则使用 yum 安装 vsftpd,如果不是,则提示您非管理员(使用 UID 数字对比版本)
if [[ $UID -eq 0 ]]; then
	#statements
	yum install vsftpd -y
else
	echo "你不是管理员，没有安装权限"
fi

9.编写脚本:提示用户输入用户名和密码,脚本自动创建相应的账户及配置密码。如果用户不输入账户名,则提示必须输入账户名并退出脚本;如果用户不输入密码,则统一使用默认的 123456 作为默认密码。
#!/bin/bash
# 编写脚本:提示用户输入用户名和密码,脚本自动创建相应的账户及配置密码。如果用户
# 不输入账户名,则提示必须输入账户名并退出脚本;如果用户不输入密码,则统一使用默
# 认的 123456 作为默认密码。
read -p "请输入用户名：" user
#使用‐z 可以判断一个变量是否为空,如果为空,提示用户必须输入账户名,并退出脚本,退出码为 2
#没有输入用户名脚本退出后,使用$?查看的返回码为 2
if [[ -z $user ]]; then
	#statements
	echo "你不需要输入账户名"
	exit 2
fi
#使用 stty ‐echo 关闭 shell 的回显功能
#使用 stty  echo 打开 shell 的回显功能
stty -echo
read -p "请输入密码：" pass
stty echo
pass=${pass:-123456}
useradd "$user"
echo "$pass" | passwd --stdin "$user"

10.输入三个数并进行升序排序
#!/bin/bash
# 依次提示用户输入 3 个整数,脚本根据数字大小依次排序输出 3 个数字
read -p "第一个数：" num1
read -p "第二个数：" num2
read -p "第三个数：" num3
# 不管谁大谁小,最后都打印 echo "$num1,$num2,$num3"
# num1 中永远存最小的值,num2 中永远存中间值,num3 永远存最大值
# 如果输入的不是这样的顺序,则改变数的存储顺序,如:可以将 num1 和 num2 的值对调
tmp=0
# 如果 num1 大于 num2,就把 num1 和和 num2 的值对调,确保 num1 变量中存的是最小值
if [[ $num1 -gt $num2 ]]; then
	#statements
	tmp=$num1
	num1=$num2
	num2=$tmp
fi
# 如果 num1 大于 num3,就把 num1 和 num3 对调,确保 num1 变量中存的是最小值
if [ $num1 -gt $num3 ];then   
  	tmp=$num1
  	num1=$num3
  	num3=$tmp
fi
# 如果 num2 大于 num3,就把 num2 和 num3 对标,确保 num2 变量中存的是小一点的值
if [ $num2 -gt $num3 ];then
  	tmp=$num2
  	num2=$num3
  	num3=$tmp
fi
echo "排序后数据(从小到大)为:$num1,$num2,$num3"

11.石头，剪刀，布
#!bin/bash
# 编写脚本,实现人机<石头,剪刀,布>游戏
game=(石头 剪刀 布)
num=$[RANDOM%3]
computer=${game[$num]}
# 通过随机数获取计算机的出拳
# 出拳的可能性保存在一个数组中,game[0],game[1],game[2]分别是 3 中不同的可能
echo "请根据下列提示选择您的出拳手势"
echo "1.石头"
echo "2.剪刀"
echo "3.布"

read -p "请选择1-3：" person
case $person in
1)
  if [[ $num -eq 0 ]]; then
  	echo "平局"
    elif [[ $num -eq 1 ]]; then
    	echo "你赢了"
  else
  	echo "计算机赢了"
	fi;;
2)
  if [[ $num -eq 0 ]]; then
  	echo "计算机赢了"
    elif [[ $num -eq 1 ]]; then
    	echo "平局"
  else
  	echo "你赢了"
  fi;;
3)
  if [[ $num -eq 0 ]]; then
  	echo "你赢了"
    elif [[ $num -eq 1 ]]; then
    	echo "计算机赢了"
  else
  	echo "平局"
  fi;;
*)
  echo "必须输入数字1-3"
esac

12.编写脚本测试 192.168.4.0/24 整个网段中哪些主机处于开机状态,哪些主机处于关机状态(for 版本)
#！bin/bash
# 编写脚本测试 192.168.4.0/24 整个网段中哪些主机处于开机状态,哪些主机处于关机
# 状态(for 版本)
for i in {1..254}; do
	#每隔0.3秒ping一次，一共ping2次，并以1毫秒为单位设置ping的超时时间
	ping -c 2 -i 0.3 -W 1 192.168.4.$i &>/dev/null
	if [ $? -eq 0 ];then
		echo "192.168.4.$i能正常链接"
	else
		echo "192.168.4.$i不能正常链接"
	fi
done

13.编写脚本测试 192.168.4.0/24 整个网段中哪些主机处于开机状态,哪些主机处于关机状态(while 版本)
#！bin/bash
# 编写脚本测试 192.168.4.0/24 整个网段中哪些主机处于开机状态,哪些主机处于关机
# 状态(while 版本) 
i=1
while [[ $i -le 254 ]]; do
	ping -c 2 -i 0.3 -W 1 192.168.4.$i &>/dev/null
	if [ $? -eq 0 ];then
		echo "192.168.4.$i能正常链接"
	else
		echo "192.168.4.$i不能正常链接"
	fi
	let i++
done

14.编写脚本测试 192.168.4.0/24 整个网段中哪些主机处于开机状态,哪些主机处于关机状态(多进程版)
#!/bin/bash
# 编写脚本测试 192.168.4.0/24 整个网段中哪些主机处于开机状态,哪些主机处于关机
# 状态(多进程版)
#定义一个函数,ping 某一台主机,并检测主机的存活状态
myping(){
	ping -c 2 -i 0.3 -W 1 $1 &>/dev/null
	if [[ $? -eq 0 ]];then
		echo "$1能正常链接"
	else
		echo "$1不能正常链接"
	fi
}
for i in {1..254}; do
	myping 192.168.4.$i &
done
# 使用&符号,将执行的函数放入后台执行
# 这样做的好处是不需要等待ping第一台主机的回应,就可以继续并发ping第二台主机,依次类推。

15.编写脚本，显示进度条
#!/bin/bash
# 编写脚本,显示进度条
jindu(){
	while :
	do
		echo -n "#"
		sleep 0.2
	done
}
jindu &
cp -a $1 $2
killall $0
echo "拷贝完成"

16.进度条,动态时针版本；定义一个显示进度的函数,屏幕快速显示|  / ‐ \
#!/bin/bash
# 进度条,动态时针版本
# 定义一个显示进度的函数,屏幕快速显示|  / ‐ \
rotate_line(){
INTERVAL=0.5  #设置间隔时间
COUNT="0"     #设置4个形状的编号,默认编号为 0(不代表任何图像)
while :
do
  COUNT=`expr $COUNT + 1` #执行循环,COUNT 每次循环加 1,(分别代表4种不同的形状)
  case $COUNT in          #判断 COUNT 的值,值不一样显示的形状就不一样
  "1")                    #值为 1 显示‐
          echo -e '‐'"\b\c"
          sleep $INTERVAL
          ;;
    "2")                  #值为 2 显示\\,第一个\是转义
          echo -e '\\'"\b\c"
          sleep $INTERVAL
          ;;
    "3")                  #值为 3 显示|
          echo -e "|\b\c"
          sleep $INTERVAL
          ;;
   "4")                   #值为 4 显示/
          echo -e "/\b\c"
          sleep $INTERVAL
          ;;
    *)                    #值为其他时,将 COUNT 重置为 0
          COUNT="0";;
    esac
done
}
rotate_line

17.9*9乘法表
#！bin/bash
# 9*9 乘法表(编写 shell 脚本,打印 9*9 乘法表)
for i in `seq 9`; do
	for j in `seq $i`; do
		echo -n "$j*$i=$[i*j]"
	done
	echo
done

18.使用死循环实时显示 eth0 网卡发送的数据包流量
#!/bin/bash
# 使用死循环实时显示 eth0 网卡发送的数据包流量
while :
do
	echo "本地eth0的流量信息如下："
	ifconfig eth0 | grep "RX packets" | awk '{print $5}'
	ifconfig eth0 | grep "TX packets" | awk '{print $5}'
	sleep 1
done

19.使用 user.txt 文件中的人员名单,在计算机中自动创建对应的账户并配置初始密码本脚本执行,需要提前准备一个 user.txt 文件,该文件中包含有若干用户名信息
#!/bin/bash
# 使用 user.txt 文件中的人员名单,在计算机中自动创建对应的账户并配置初始密码
# 本脚本执行,需要提前准备一个 user.txt 文件,该文件中包含有若干用户名信息
for i in `cat user.txt`
do
	useradd $i
	echo "123456" | passwd --stdin $i
done

20.编写批量修改扩展名脚本
#!/bin/bash 
# 编写批量修改扩展名脚本,如批量将 txt 文件修改为 doc 文件 
# 执行脚本时,需要给脚本添加位置参数
# 脚本名  txt  doc(可以将 txt 的扩展名修改为 doc)
# 脚本名  doc  jpg(可以将 doc 的扩展名修改为 jpg)
for i in `ls *.$1`; do
	mv $i ${i%.*}.$2
done

21.使用 expect 工具自动交互密码远程其他主机安装 httpd 软件
#!/bin/bash
# 使用 expect 工具自动交互密码远程其他主机安装 httpd 软件 
# 删除~/.ssh/known_hosts 后,ssh 远程任何主机都会询问是否确认要连接该主机
rm  ‐rf  ~/.ssh/known_hosts
expect <<EOF
spawn ssh 192.168.4.254
expect "yes/no" {send "yes\r"}
# 根据自己的实际情况将密码修改为真实的密码字串
expect "password" {send  "密码\r"}
expect "#" {send  "yum ‐y install httpd\r"}
expect "#" {send  "exit\r"}
EOF

22.一键部署LNMP(源码安装版本)
#!bin/bash
#一键部署LNMP,系统：centos7
#菜单
menu()
{
  clear
  echo "##############------菜单------###############"
  echo "#1.安装 Nginx18"
  echo "#2.安装 Mysql5.7"
  echo "#3.安装 PHP7.0"
  echo "#4. 退出程序"
  echo "#############################################"
}

#选择
choice()
{
  read -p "请输入菜单[1-4]：" select
}
#安装Nginx
install_nginx()
{
  id nginx &>/dev/null
  if [[ $? -ne 0 ]]; then
    #statements
    useradd -s /sbin/nologin nginx
  fi
  wget http://nginx.org/download/nginx-1.18.0.tar.gz && tar -zxvf nginx-1.18.0.tar.gz && cd nginx-1.18.0 
  yum install gcc gcc-c++ make pcre pcre-devel zlib zlib-devel openssl openssl-devel -y
  ./configure --prefix=/usr/local/nginx --without-http_memcached_module --user=nginx --group=nginx --with-http_stub_status_module --with-http_ssl_module --with-http_gzip_static_module
  make && make install 
  cd && mkdir -p .vim && cp -r nginx-1.18.0/contrib/vim/* .vim
  /usr/local/nginx/sbin/nginx
echo '#!/bin/sh
#
# nginx - this script starts and stops the nginx daemon
#
# chkconfig:   - 85 15
# description:  NGINX is an HTTP(S) server, HTTP(S) reverse \
#               proxy and IMAP/POP3 proxy server
# processname: nginx
# config:      /usr/local/nginx/conf/nginx.conf
# config:      /etc/sysconfig/nginx
# pidfile:     /usr/local/nginx/logs/nginx.pid
# Source function library.
. /etc/rc.d/init.d/functions
# Source networking configuration.
. /etc/sysconfig/network
# Check that networking is up.
[ "$NETWORKING" = "no" ] && exit 0
nginx="/usr/local/nginx/sbin/nginx"
prog=$(basename $nginx)
NGINX_CONF_FILE="/usr/local/nginx/conf/nginx.conf"
[ -f /etc/sysconfig/nginx ] && . /etc/sysconfig/nginx
lockfile=/var/lock/subsys/nginx
make_dirs() {
   # make required directories
   user=`$nginx -V 2>&1 | grep "configure arguments:" | sed 's/[^*]*--user=\([^ ]*\).*/\1/g' -`
   if [ -z "`grep $user /etc/passwd`" ]; then
       useradd -M -s /bin/nologin $user
   fi
   options=`$nginx -V 2>&1 | grep 'configure arguments:'`
   for opt in $options; do
       if [ `echo $opt | grep '.*-temp-path'` ]; then
           value=`echo $opt | cut -d "=" -f 2`
           if [ ! -d "$value" ]; then
               # echo "creating" $value
               mkdir -p $value && chown -R $user $value
           fi
       fi
   done
}
start() {
    [ -x $nginx ] || exit 5
    [ -f $NGINX_CONF_FILE ] || exit 6
    make_dirs
    echo -n $"Starting $prog: "
    daemon $nginx -c $NGINX_CONF_FILE
    retval=$?
    echo
    [ $retval -eq 0 ] && touch $lockfile
    return $retval
}
stop() {
    echo -n $"Stopping $prog: "
    killproc $prog -QUIT
    retval=$?
    echo
    [ $retval -eq 0 ] && rm -f $lockfile
    return $retval
}
restart() {
    configtest || return $?
    stop
    sleep 1
    start
}
reload() {
    configtest || return $?
    echo -n $"Reloading $prog: "
    killproc $nginx -HUP
    RETVAL=$?
    echo
}
force_reload() {
    restart
}
configtest() {
  $nginx -t -c $NGINX_CONF_FILE
}
rh_status() {
    status $prog
}
rh_status_q() {
    rh_status >/dev/null 2>&1
}
case "$1" in
    start)
        rh_status_q && exit 0
        $1
        ;;
    stop)
        rh_status_q || exit 0
        $1
        ;;
    restart|configtest)
        $1
        ;;
    reload)
        rh_status_q || exit 7
        $1
        ;;
    force-reload)
        force_reload
        ;;
    status)
        rh_status
        ;;
    condrestart|try-restart)
        rh_status_q || exit 0
            ;;
    *)
        echo $"Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest}"
        exit 2
esac' > /etc/init.d/nginx

chkconfig --add /etc/init.d/nginx
chmod 755 /etc/init.d/nginx
chkconfig --add nginx
systemctl start nginx

exit 2
}

#安装mysql5.7
install_mysql()
{
    wget https://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm
    rpm -ivh mysql57-community-release-el7-9.noarch.rpm
    yum install mysql-server -y
    systemctl start mysqld
    sleep 2

    defaultmysqlpwd=`grep 'temporary password' /var/log/mysqld.log | awk -F"root@localhost: " '{ print $2}' `
    mysql -uroot -p${defaultmysqlpwd}<<EOF
    set global validate_password_policy = 0;
    SET PASSWORD = PASSWORD('19910901');
    grant all privileges on *.* to root@'%' identified by '19910901';
EOF

    sleep 2
    systemctl restart mysqld

    exit 2

}
#安装mysql8
#wget http://repo.mysql.com/mysql80-community-release-el7-3.noarch.rpm
#rpm -ivh mysql80-community-release-el7-3.noarch.rpm
#rpm -e mariadb*
#yum install mysql-server -y
#alter user 'root'@'localhost' identified by 'password';
#set global validate_password.policy=0;set global validate_password.length=4;
#安装php7.0
install_php()
{
   yum -y install epel-release 
   rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm
   rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm
   yum install php70w-common php70w-fpm php70w-opcache php70w-gd php70w-mysqlnd php70w-mbstring php70w-pecl-redis php70w-pecl-memcached php70w-devel -y
   systemctl start php-fpm
   #可安装扩展
   #php-api, php-bz2, php-calendar, php-ctype, php-curl, php-date, php-exif, php-fileinfo, php-filter, php-ftp, php-gettext, php-gmp, php-hash, php-iconv, php-json, php-libxml, php-openssl, php-pcre, php-pecl-Fileinfo, php-pecl-phar, php-pecl-zip, php-reflection, php-session, php-shmop, php-simplexml, php-sockets, php-spl, php-tokenizer, php-zend-abi, php-zip, php-zlib
   exit 2
}
#选择安装的函数 
while :
do
menu
choice
case $select in
1)
install_nginx
;;
2)
install_mysql
;;
3)
install_php
;;
4)
exit
;;
*)
echo Sorry!
esac
done


23.编写脚本快速克隆 KVM 虚拟机

24.点名器脚本
#！bin/bash
# 编写一个点名器脚本
# 该脚本,需要提前准备一个 user.txt 文件
# 该文件中需要包含所有姓名的信息,一行一个姓名,脚本每次随机显示一个姓名
while :
do
#统计user文件中有多少用户
line=`cat user.txt | wc -l`
num=$[RANDOM%line+1]
sed -n "${num}p" user.txt
sleep 0.2
clear
done

25.查看有多少远程的 IP 在连接本机
#!bin/bash
# 查看有多少远程的 IP 在连接本机(不管是通过 ssh 还是 web 还是 ftp 都统计) 
# 使用 netstat ‐atn 可以查看本机所有连接的状态,‐a 查看所有,
# -t仅显示 tcp 连接的信息,‐n 数字格式显示
# Local Address(第四列是本机的 IP 和端口信息)
# Foreign Address(第五列是远程主机的 IP 和端口信息)
# 使用 awk 命令仅显示第 5 列数据,再显示第 1 列 IP 地址的信息
# sort 可以按数字大小排序,最后使用 uniq 将多余重复的删除,并统计重复的次数
netstat -atn  |  awk  '{print $5}'  | awk  '{print $1}' | sort -nr  |  uniq -c